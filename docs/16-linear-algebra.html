<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-03-31 Tue 07:32 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Applications in Linear algebra</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="John Kitchin" />
<meta name="keywords" content="numpy.linalg.solve" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Applications in Linear algebra</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org69ef4c1">1. Applications of linear algebra</a>
<ul>
<li><a href="#orgae8c102">1.1. Application in reaction engineering - Steady state CSTR</a></li>
<li><a href="#org6b61bdf">1.2. Finding independent reactions</a></li>
<li><a href="#org41b01bd">1.3. Application in linear boundary value problems</a></li>
</ul>
</li>
<li><a href="#org1c002c5">2. Things to look out for</a></li>
<li><a href="#org31c36ac">3. Leveraging linear algebra for iteration</a></li>
<li><a href="#org56bc029">4. Summary</a></li>
</ul>
</div>
</div>

<div id="outline-container-org69ef4c1" class="outline-2">
<h2 id="org69ef4c1"><span class="section-number-2">1</span> Applications of linear algebra</h2>
<div class="outline-text-2" id="text-1">
<p>
Linear algebra is used extensively in engineering applications. Here we consider some examples.
</p>
</div>

<div id="outline-container-orgae8c102" class="outline-3">
<h3 id="orgae8c102"><span class="section-number-3">1.1</span> Application in reaction engineering - Steady state CSTR</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Suppose we have first order reactions occurring in a CSTR. We can represent the concentrations of each species in the reactor as a vector: \(C = [C_A, C_C, C_D, ...]\).
</p>

<p>
Let the reactions be \(A \rightarrow C\) and \(C \rightarrow D\). These reactions happen at these rates:
</p>

<p>
\(r_1 = k_1 C_A\) and \(r_2 = k_2 C_C\).
</p>

<p>
We assume a constant volume \(V\), and volumetric flow rate \(\nu\) into a CSTR, and steady state. It is convenient to define \(\tau = V / \nu\). With these assumptions, we can derive the following species mole balances:
</p>

<p>
\(0 = C_{A, feed} - C_A - \tau k_1 C_A\)
</p>

<p>
\(0 = C_{C, feed} - C_C + \tau k_1 C_A - \tau k_2 C_C\)
</p>

<p>
\(0 = C_{D, feed} - C_D + \tau k_2 C_C\)
</p>

<p>
These are not particularly in a useful form, since they do not resemble \(\mathbf{A} \mathbf{x} = \mathbf{b}\). We can rearrange them to achieve that. We need all the variables on the left, and any constant terms on the right.
</p>

<p>
\(C_A + \tau k_1 C_A = C_{A, feed}\)
</p>

<p>
\(C_C - \tau k_1 C_A + \tau k_2 C_C = C_{C, feed}\)
</p>

<p>
\(C_D - \tau k_2 C_C = C_{D, feed}\)
</p>

<p>
Now, we can start to see some structure emerge. Let \(\mathbf{C} = [C_A, C_C, C_D]\).
</p>

<p>
Let \(\mathbf{A} = \left[\begin{array}{ccc}
 1 + \tau k_1 & 0 & 0 \\
 -\tau k_1 & 1 + \tau k_2 & 0 \\
 0 & -\tau k_2 & 1
 \end{array}\right]\)
</p>

<p>
and finally, we have \(\mathbf{C_{feed}} = [C_{A,feed}, C_{C, feed}, C_{D, feed}]\). Or, all together:
</p>

<p>
\(\mathbf{A} \mathbf{C} = \mathbf{C_{feed}}\).
</p>

<p>
Note that we have been talking about these as linear equations, but,  we may also think of them as transformations. Consider this:
</p>

<p>
\(\mathbf{A}^{-1} \mathbf{C_{feed}} = \mathbf{C}\).
</p>

<p>
Here we can see that \(\mathbf{A}^{-1}\) transforms the feed concentrations into the exit concentrations.
</p>

<p>
Solving these equations is now straightfoward:
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">tau</span> = 2.5  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Residence time (min)</span>
<span style="color: #BA36A5;">C_feed</span> = [2.2, 0.0, 0.0] <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mol / L</span>
<span style="color: #BA36A5;">k1</span> = 2.3  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">1/min</span>
<span style="color: #BA36A5;">k2</span> = 4.5  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">1/min</span>

<span style="color: #BA36A5;">A</span> = np.array([[1 + tau * k1, 0.0, 0.0],
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> [-tau * k1, 1 + tau * k2, 0.0],
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> [0.0, -tau * k2, 1]])

<span style="color: #BA36A5;">C_A</span>, <span style="color: #BA36A5;">C_C</span>, <span style="color: #BA36A5;">C_D</span> = np.linalg.solve(A, C_feed)

<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'The exit concentrations are C_A=</span><span style="color: #BA36A5;">{C_A:1.2f}</span><span style="color: #008000;">, C_C=</span><span style="color: #BA36A5;">{C_C:1.2f}</span><span style="color: #008000;">, C_D=</span><span style="color: #BA36A5;">{C_D:1.2f}</span><span style="color: #008000;"> mol/L'</span>)
</pre>
</div>

<p>
The exit concentrations are C_A=0.33, C_C=0.15, C_D=1.72 mol/L
</p>
</div>
</div>

<div id="outline-container-org6b61bdf" class="outline-3">
<h3 id="org6b61bdf"><span class="section-number-3">1.2</span> Finding independent reactions</h3>
<div class="outline-text-3" id="text-1-2">
<p>
reference: Exercise 2.4 in Chemical Reactor Analysis and Design Fundamentals by Rawlings and Ekerdt.
</p>

<p>
The following reactions are proposed in the hydrogenation of bromine. The reactions are defined by \(\mathbf{M} \mathbf{v}\)  where \(\mathbf{M}\) is a stoichometric matrix in which each row represents a reaction with negative stoichiometric coefficients for reactants, and positive stoichiometric coefficients for products. A stoichiometric coefficient of 0 is used for species not participating in the reaction.  The species vector is \(\mathbf{v}\) = [H2 H Br2 Br HBr].T
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #8D8D84;">#               </span><span style="color: #8D8D84; font-style: italic;">[H2  H Br2 Br HBr]</span>
<span style="color: #BA36A5;">M</span> = np.array([[-1,  0, -1,  0,  2],  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">H2 + Br2 == 2HBR</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> [ 0,  0, -1,  2,  0],  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Br2 == 2Br</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> [-1,  1,  0, -1,  1],  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Br + H2 == HBr + H</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> [ 0, -1, -1,  1,  1],  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">H + Br2 == HBr + Br</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> [ 1, -1,  0,  1,  -1], <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">H + HBr == H2 + Br</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> [ 0,  0,  1, -2,  0]])  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">2Br == Br2</span>
</pre>
</div>

<p>
We can check to see how many independent rows there are, this is equal to the rank of the matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython">np.linalg.matrix_rank(M)
</pre>
</div>

<pre class="example">
3
</pre>

<p>
You can see based on this result that there are only three independent equations. Now we consider how to identify three of them. We need to manipulate \(\mathbf{M}\) to eliminate at least three rows. We can see by inspection that rows 1 and 5 are linearly related. If we add row 1 to row 5, we will get a row of zeros. That means these two rows are linearly independent.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">M</span>[5] += M[1]
M
</pre>
</div>

<pre class="example">
array([[-1,  0, -1,  0,  2],
       [ 0,  0, -1,  2,  0],
       [-1,  1,  0, -1,  1],
       [ 0, -1, -1,  1,  1],
       [ 1, -1,  0,  1, -1],
       [ 0,  0,  0,  0,  0]])
</pre>

<p>
Further inspection shows Row 0 is the sum of rows 2 and 3.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">M</span>[0] -= M[2] + M[3]
M
</pre>
</div>

<pre class="example">
array([[ 0,  0,  0,  0,  0],
       [ 0,  0, -1,  2,  0],
       [-1,  1,  0, -1,  1],
       [ 0, -1, -1,  1,  1],
       [ 1, -1,  0,  1, -1],
       [ 0,  0,  0,  0,  0]])
</pre>

<p>
Finally reaction 2 is the opposite of reaction 4
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">M</span>[2] += M[4]
M
</pre>
</div>

<pre class="example">
array([[ 0,  0,  0,  0,  0],
       [ 0,  0, -1,  2,  0],
       [ 0,  0,  0,  0,  0],
       [ 0, -1, -1,  1,  1],
       [ 1, -1,  0,  1, -1],
       [ 0,  0,  0,  0,  0]])
</pre>

<p>
We have successfully eliminated three reactions by linear combinations of other reactions. We can reorder the array like this to put the non-zero rows at the top.
</p>

<div class="org-src-container">
<pre class="src src-ipython">M[[1, 3, 4, 0, 2, 5]]
</pre>
</div>

<pre class="example">
array([[ 0,  0, -1,  2,  0],
       [ 0, -1, -1,  1,  1],
       [ 1, -1,  0,  1, -1],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0],
       [ 0,  0,  0,  0,  0]])
</pre>

<p>
We can print these in a more readable form like this:
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">labels</span> = [<span style="color: #008000;">'H2'</span>,  <span style="color: #008000;">'H'</span>, <span style="color: #008000;">'Br2'</span>, <span style="color: #008000;">'Br'</span>, <span style="color: #008000;">'HBr'</span>]
<span style="color: #0000FF;">for</span> row <span style="color: #0000FF;">in</span> M:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> <span style="color: #0000FF;">not</span> np.<span style="color: #006FE0;">all</span>(row == 0):  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">ignore rows that are all zeros</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">s</span> = <span style="color: #008000;">'0 = '</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> nu, species <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(row, labels):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> nu != 0:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">s</span> += <span style="color: #008000;">' {0:+d}{1}'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #006FE0;">int</span>(nu), species)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(s)
</pre>
</div>

<p>
0 =  -1Br2 +2Br
0 =  -1H -1Br2 +1Br +1HBr
0 =  +1H2 -1H +1Br -1HBr
</p>

<p>
That representation is a little clunky, but it is tricky to get more conventional looking reactions:
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">labels</span> = [<span style="color: #008000;">'H2'</span>,  <span style="color: #008000;">'H'</span>, <span style="color: #008000;">'Br2'</span>, <span style="color: #008000;">'Br'</span>, <span style="color: #008000;">'HBr'</span>]
<span style="color: #0000FF;">for</span> row <span style="color: #0000FF;">in</span> M:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> <span style="color: #0000FF;">not</span> np.<span style="color: #006FE0;">all</span>(row == 0):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">reactants</span>, <span style="color: #BA36A5;">products</span> = [], []
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> nu, species <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(row, labels):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> nu &lt; 0:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">reactants</span> += [f<span style="color: #008000;">' </span><span style="color: #BA36A5;">{"" if nu == -1 else -int(nu)}{species}</span><span style="color: #008000;">'</span>]
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">elif</span> nu &gt; 0:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">products</span> += [f<span style="color: #008000;">' </span><span style="color: #BA36A5;">{"" if nu == 1 else int(nu)}{species}</span><span style="color: #008000;">'</span>]
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">reactants</span> = <span style="color: #008000;">' + '</span>.join(reactants)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">products</span> = <span style="color: #008000;">' + '</span>.join(products)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'</span><span style="color: #BA36A5;">{reactants}</span><span style="color: #008000;"> -&gt; </span><span style="color: #BA36A5;">{products}</span><span style="color: #008000;">'</span>)
</pre>
</div>

<p>
Br2 -&gt;  2Br
H +  Br2 -&gt;  Br +  HBr
H +  HBr -&gt;  H2 +  Br
</p>

<p>
What we did by hand was to put the matrix into reduced row echelon form. It is not common to do this by hand. One way to get the computer to do this for you is to use <a href="https://www.sympy.org/en/index.html">sympy</a>. This is a symbolic math package for Python that is similar to Mathematica and Maple in its ability to do symbolic (as opposed to numeric) manipulations.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> sympy
sympy.Matrix.rref?
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> sympy
<span style="color: #BA36A5;">M</span> = sympy.Matrix(M)
<span style="color: #BA36A5;">reduced_form</span>, <span style="color: #BA36A5;">inds</span> = M.rref()

reduced_form
</pre>
</div>

<pre class="example">
Matrix([
[1, 0, 0,  2, -2],
[0, 1, 0,  1, -1],
[0, 0, 1, -2,  0],
[0, 0, 0,  0,  0],
[0, 0, 0,  0,  0],
[0, 0, 0,  0,  0]])
</pre>



<p>
Note that a <i>Matrix</i> is not the same as an array. You can convert it to one like this:
</p>

<div class="org-src-container">
<pre class="src src-ipython">np.array(reduced_form).astype(np.<span style="color: #006FE0;">float</span>)
</pre>
</div>

<p>
:results:
</p>

<pre class="example">
array([[ 1.,  0.,  0.,  2., -2.],
       [ 0.,  1.,  0.,  1., -1.],
       [ 0.,  0.,  1., -2.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.]])
</pre>

<p>
From here you can use the code from above to construct the equations.
</p>
</div>
</div>


<div id="outline-container-org41b01bd" class="outline-3">
<h3 id="org41b01bd"><span class="section-number-3">1.3</span> Application in linear boundary value problems</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Let us consider pressure driven flow again.
</p>

<p>
\(\frac{d^2 v_x}{dy^2} = \frac{1}{\mu}\frac{\Delta P}{\Delta x}\)
</p>

<p>
This is a boundary value problem where \(v_x(y=0) = 0\) and \(v_x(y=B) = 0\). The solution is well-known and parabolic.
</p>

<p>
We previously used <code>scipy.integrate.solve_bvp</code> for this. Recall that it is necessary to create an initial guess of the solution, and that can be tricky. Here we consider an alternative approach to solving it using a method of finite differences.
</p>


<p>
We can write the second derivative as an approximate finite difference formula:
</p>

<p>
\(f''(x) \approx \frac{f(x + h) - 2 f(x) + f(x-h)}{h^2}\)
</p>

<p>
Let's discretize the domain and then see if we can solve for the velocity at the discretized points.
</p>

<p>
At each point, we can estimate the second derivative as:
</p>

<p>
\(\frac{d^2 v}{dy^2} \approx \frac{v_{j+1} - 2 v_j + v_{j-1}}{h^2} = \frac{\Delta P}{\mu\Delta x}\)
</p>

<p>
How does this help us? The \(v_j\) are variables that we want to solve for. With a little rearrangement we have:
</p>

<p>
\(v_{j+1} - 2 v_j + v_{j-1} = \frac{h^2 \Delta P}{\mu\Delta x} = G\)
</p>

<p>
Let's write a few of these out, starting at \(j=1\) up to \(j=N-1\):
</p>

<p>
\(v_2 - 2 v_1 + v_0 = G\)
</p>

<p>
\(v_3 - 2 v_2 + v_1 = G\)
</p>

<p>
&#x2026;
</p>

<p>
\(v_{N} - 2 v_{N-1} + v_{N-2} = G\)
</p>

<p>
If we define \(\mathbf{v} = [v_1, v_2, ... v_{N-1}]\) (remember we know \(v_0\) and \(v_{N}\) from the boundary conditions), we can see the following structure emerge:
</p>

<p>
Let \(\mathbf{A} = \left[\begin{array}{ccccc}
 -2 & 1 & 0 & ... & 0 \\
 1 & -2 & 1 & ...& 0\\
 \vdots\\
 0 & ... & 0 & 1 & -2
 \end{array}\right]\)
</p>

<p>
This matrix is sparse (most entries are zero), and diagonal. The diagonal is always -2, and the diagonal above and below the main diagonal is always 1. Note that some derivations of this move a minus sign into the \(\mathbf{G}\), but it does not change anything. Let's consider how to construct a matrix like this.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">A</span> = np.eye(5) * -2
<span style="color: #BA36A5;">L</span> = np.diag(np.ones(4), -1)
<span style="color: #BA36A5;">U</span> = np.diag(np.ones(4), 1)
A + L + U
</pre>
</div>

<pre class="example">
array([[-2.,  1.,  0.,  0.,  0.],
       [ 1., -2.,  1.,  0.,  0.],
       [ 0.,  1., -2.,  1.,  0.],
       [ 0.,  0.,  1., -2.,  1.],
       [ 0.,  0.,  0.,  1., -2.]])
</pre>


<p>
And we can define \(\mathbf{G} = [G - v_0, G, G, ..., G - v_N]\) so that we have the following linear equation that is easy to solve:
</p>

<p>
\(\mathbf{A} \mathbf{v} = \mathbf{G}\). The only issue is how to code this up conveniently?
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">B</span> = 0.2

<span style="color: #BA36A5;">N</span> = 10  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">You need to use enough points to make sure the derivatives are</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">reasonably approximated</span>

<span style="color: #BA36A5;">y</span>, <span style="color: #BA36A5;">h</span> = np.linspace(0, B, N, retstep=<span style="color: #D0372D;">True</span>)

<span style="color: #BA36A5;">A</span> = np.eye(<span style="color: #006FE0;">len</span>(y) - 2) * -2
<span style="color: #BA36A5;">L</span> = np.diag(np.ones(<span style="color: #006FE0;">len</span>(y) - 3), -1) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">lower diagonal</span>
<span style="color: #BA36A5;">U</span> = np.diag(np.ones(<span style="color: #006FE0;">len</span>(y) - 3), 1) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">upper diagonal</span>
<span style="color: #BA36A5;">A</span> = A + L + U
A  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">always a good idea to check we have the right structure.</span>
</pre>
</div>

<pre class="example">
array([[-2.,  1.,  0.,  0.,  0.,  0.,  0.,  0.],
       [ 1., -2.,  1.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  1., -2.,  1.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  1., -2.,  1.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  1., -2.,  1.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  1., -2.,  1.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  1., -2.,  1.],
       [ 0.,  0.,  0.,  0.,  0.,  0.,  1., -2.]])
</pre>

<p>
Now we create the \(\mathbf{G}\) vector.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">mu</span> = 2
<span style="color: #BA36A5;">deltaPx</span> = -50
<span style="color: #BA36A5;">v0</span> = <span style="color: #BA36A5;">vB</span> = 0.0

<span style="color: #BA36A5;">G</span> = np.ones(<span style="color: #006FE0;">len</span>(y) - 2) * deltaPx / mu * h**2
<span style="color: #BA36A5;">G</span>[0] += v0
<span style="color: #BA36A5;">G</span>[-1] += vB
</pre>
</div>

<p>
Now, solving this is simple, no initial guesses required since it is a linear problem.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">vx</span> = np.linalg.solve(A, G)

%matplotlib inline
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

plt.plot(y, np.concatenate([[v0], vx, [vB]]))
plt.xlabel(<span style="color: #008000;">'y'</span>)
plt.ylabel(<span style="color: #008000;">'$v_x$'</span>)
plt.xlim([0, B])
plt.ylim([0, 0.15])
</pre>
</div>

<pre class="example">
(0, 0.15)
</pre>


<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>



<div class="figure">
<p><img src="obipy-resources/46d11300443dc16a9fff087bcb1206e887d46a8e/56220be512c3772989fd18054150867c11debad4.png" alt="56220be512c3772989fd18054150867c11debad4.png" />
</p>
</div>


<p>
Note that we have approximated the solution by discretizing and estimating the derivatives that the points. You have to check for convergence by increasing the number of points \(N\).
</p>

<p>
This method worked because the BVP was <i>linear</i>, i.e. no products, powers, etc of derivatives, so that the final set of equations after discretization was linear. If the BVP was nonlinear, we would end up with a set of coupled nonlinear equations that you would have to use <code>scipy.optimize.fsolve</code> to solve, or <code>scipy.integrate.solve_bvp</code>, and these would both require an initial guess to solve.
</p>
</div>
</div>
</div>

<div id="outline-container-org1c002c5" class="outline-2">
<h2 id="org1c002c5"><span class="section-number-2">2</span> Things to look out for</h2>
<div class="outline-text-2" id="text-2">
<p>
Just because systems are linear doesn't mean they are well-behaved. Seemingly simple equations can show unexpected behavior. Consider
</p>

<p>
\(-0.5 x1 + x2 = 1.1\)
</p>

<p>
and
</p>

<p>
\(-0.46 x1 + x2 = 1.0\)
</p>

<p>
These are easy to solve.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">A</span> = np.array([[-0.5, 1],
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> [-0.46, 1]])
<span style="color: #BA36A5;">b</span> = np.array([1.1, 1])

np.linalg.solve(A, b)
</pre>
</div>

<pre class="example">
array([-2.5 , -0.15])
</pre>

<p>
Now consider this slightly different system where we just change -0.46 to -0.47. Surely that should not be a big deal right?
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">A</span> = np.array([[-0.5, 1],
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> [-0.47, 1]])

<span style="color: #BA36A5;">b</span> = np.array([1.1, 1])

np.linalg.solve(A, b)
</pre>
</div>

<pre class="example">
array([-3.33333333, -0.56666667])
</pre>

<p>
That seems like a big change in the answer for such a small change in one coefficient. What is happening? The determinant of this matrix is small, and the condition number is high, which means it is an ill-conditioned system of equations.
</p>

<div class="org-src-container">
<pre class="src src-ipython">np.linalg.det(A), np.linalg.cond(A)
</pre>
</div>

<pre class="example">
(-0.030000000000000023, 82.3511902180071)
</pre>

<p>
Graphically, this means the two lines are nearly parallel, so even the smallest shift in the slope will result in a large change in the intersection.
</p>

<div class="org-src-container">
<pre class="src src-ipython">%matplotlib inline
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">x1</span> = np.linspace(-6, 0)
<span style="color: #BA36A5;">x2_0</span> = 1.1 + 0.5 * x1
<span style="color: #BA36A5;">x2_1</span> = 1.0 + 0.47 * x1

plt.plot(x1, x2_0, x1, x2_1)
plt.xlabel(<span style="color: #008000;">'x1'</span>)
plt.ylabel(<span style="color: #008000;">'x2'</span>)
</pre>
</div>

<pre class="example">
Text(0, 0.5, 'x2')
</pre>


<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>



<div class="figure">
<p><img src="obipy-resources/46d11300443dc16a9fff087bcb1206e887d46a8e/e135a0db42887ff178d4c38c915678bc3b0c1912.png" alt="e135a0db42887ff178d4c38c915678bc3b0c1912.png" />
</p>
</div>

<p>
This system of equations is sensitive to roundoff errors, both in the coefficients of \(\mathbf{A}\) and in the numerics of solving the equations.
</p>
</div>
</div>
<div id="outline-container-org31c36ac" class="outline-2">
<h2 id="org31c36ac"><span class="section-number-2">3</span> Leveraging linear algebra for iteration</h2>
<div class="outline-text-2" id="text-3">
<p>
Linear algebra can be used for iteration (for loops) in some cases. Doing this is usually faster because dedicated linear algebra libraries are very fast, and the code is usually shorter. However, it is trickier to write sometimes, and not everything can be done this way.
</p>

<p>
It can also be advantageous to use this approach in machine learning. Some frameworks are difficult to use loops in.
</p>

<p>
The dot product is defined as:
</p>

<p>
\(\mathbf{a}\cdot\mathbf{b} = \sum_{i=0}^{N-1} a_i b_i\)
</p>

<p>
For specificity we have these two vectors to start with:
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #BA36A5;">a</span> = np.array([1, 2, 3, 4, 5])
<span style="color: #BA36A5;">b</span> = np.array([3, 6, 8, 9, 10])
</pre>
</div>

<p>
As defined, we could implement the dot product as:
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">dp</span> = 0
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(<span style="color: #006FE0;">len</span>(a)):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">dp</span> += a[i] * b[i]

dp
</pre>
</div>

<pre class="example">
125
</pre>

<p>
We can do better than that with elementwise multiplication:
</p>

<div class="org-src-container">
<pre class="src src-ipython">np.<span style="color: #006FE0;">sum</span>(a * b)
</pre>
</div>

<pre class="example">
125
</pre>

<p>
The best approach, however, is the linear algebra approach:
</p>

<div class="org-src-container">
<pre class="src src-ipython">a @ b
</pre>
</div>

<pre class="example">
125
</pre>

<p>
Why is this better?
</p>

<ol class="org-ol">
<li>It is short.</li>
<li>It does not specify how the computation is done. This allows it to be done with an optimized (i.e. fast) and possibly parallelized algorithm. <i>Many</i> very smart people have worked hard to make linear algebra fast; we should try not to implement it ourselves.</li>
</ol>


<p>
Consider \(y = \sum\limits_{i=1}^n w_i x_i^2\). This operation is like a weighted sum of squares.
</p>

<p>
The old-fashioned way to do this is with a loop.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">w</span> = np.array([0.1, 0.25, 0.12, 0.45, 0.98])
<span style="color: #BA36A5;">x</span> = np.array([9, 7, 11, 12, 8])

<span style="color: #BA36A5;">y</span> = 0
<span style="color: #0000FF;">for</span> wi, xi <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(w, x):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>  <span style="color: #BA36A5;">y</span> += wi * xi**2
y
</pre>
</div>

<pre class="example">
162.39
</pre>

<p>
Compare this to the more modern numpy approach.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">y</span> = np.<span style="color: #006FE0;">sum</span>(w * x**2)
</pre>
</div>

<p>
We can also express this in matrix algebra form. The operation is equivalent to \(y = \mathbf{x} \cdot \mathbf{D_w} \cdot \mathbf{x}^T\) where \(\mathbf{D_w}\) is a diagonal matrix with the weights on the diagonal.
</p>

<div class="org-src-container">
<pre class="src src-ipython">x @ np.diag(w) @ x
</pre>
</div>

<pre class="example">
162.39
</pre>

<p>
Finally, consider the sum of the product of three vectors. Let \(y = \sum\limits_{i=1}^n w_i x_i y_i\). This is like a weighted sum of products.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">w</span> = np.array([0.1, 0.25, 0.12, 0.45, 0.98])
<span style="color: #BA36A5;">x</span> = np.array([9, 7, 11, 12, 8])
<span style="color: #BA36A5;">y</span> = np.array([2, 5, 3, 8, 0])

<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">sum</span>(w * x * y))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">numpy vectorized approach</span>
w @ np.diag(x) @ y <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">linear algebra approach</span>
</pre>
</div>

<p>
57.71
</p>

<pre class="example">
57.71000000000001
</pre>
</div>
</div>


<div id="outline-container-org56bc029" class="outline-2">
<h2 id="org56bc029"><span class="section-number-2">4</span> Summary</h2>
<div class="outline-text-2" id="text-4">
<p>
In this lecture we considered several applications of linear algebra including:
</p>
<ol class="org-ol">
<li>Solutions to steady state mass balances</li>
<li>Finding independent reactions</li>
<li>Solving linear boundary value problems</li>
</ol>

<p>
We also briefly touched on vectorized approaches to using linear algebra to avoid writing explicit loops.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: John Kitchin</p>
<p class="date">Created: 2020-03-31 Tue 07:32</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
