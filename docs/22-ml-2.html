<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-03-31 Tue 07:32 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Machine learning</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="John Kitchin" />
<meta name="keywords" content="autograd" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Machine learning</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0b62e42">1. Choice of activation functions in neural networks</a>
<ul>
<li><a href="#org0fa53c5">1.1. tanh</a></li>
<li><a href="#orgb3fd1b0">1.2. relu</a></li>
<li><a href="#orgea866a1">1.3. Gaussian (radial basis function)</a></li>
<li><a href="#org062a653">1.4. Summary</a></li>
</ul>
</li>
<li><a href="#org8e4d192">2. Train/test splits on data</a></li>
<li><a href="#orgaff0d8a">3. Summary</a></li>
</ul>
</div>
</div>


<div id="outline-container-org0b62e42" class="outline-2">
<h2 id="org0b62e42"><span class="section-number-2">1</span> Choice of activation functions in neural networks</h2>
<div class="outline-text-2" id="text-1">
<p>
The activation function in a neural network provides the nonlinearity in the model. We previously learned that one interpretation of the activation function is that it is a basis function that you can expand the data in to find a functional representation that fits the data.
</p>

<p>
Today we explore the impact of the activation function on the fitting, and extrapolation of neural networks. The following code is for setting up a neural network, and initializing the parameters with random numbers.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> autograd.numpy.random <span style="color: #0000FF;">as</span> npr

<span style="color: #0000FF;">def</span> <span style="color: #006699;">nn</span>(params, inputs, activation=np.tanh):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #036A07;">"""a neural network.</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span><span style="color: #036A07;">   params is a list of (weights, bias) for each layer.</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span><span style="color: #036A07;">   inputs goes into the nn. Each row corresponds to one output label.</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span><span style="color: #036A07;">   activation is the nonlinear activation function.</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span><span style="color: #036A07;">   """</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> W, b <span style="color: #0000FF;">in</span> params[:-1]:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">outputs</span> = np.dot(inputs, W) + b
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">inputs</span> = activation(outputs)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">no activation on the last layer</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">W</span>, <span style="color: #BA36A5;">b</span> = params[-1]
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.dot(inputs, W) + b

<span style="color: #0000FF;">def</span> <span style="color: #006699;">init_random_params</span>(scale, layer_sizes, rs=npr.RandomState(0)):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #036A07;">"""Build a list of (weights, biases) tuples, one for each layer."""</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> [(rs.randn(insize, outsize) * scale,   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">weight matrix</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>rs.randn(outsize) * scale)           <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">bias vector</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> insize, outsize <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(layer_sizes[:-1], layer_sizes[1:])]
</pre>
</div>

<p>
As before, we are going to consider this dataset so we can evaluate fitting and extrapolation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Some generated data</span>
<span style="color: #BA36A5;">X</span> = np.linspace(0, 1)
<span style="color: #BA36A5;">Y</span> = X**(1. / 3.)

%matplotlib inline
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(X, Y, <span style="color: #008000;">'b.'</span>)
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>)
</pre>
</div>

<pre class="example">
Text(0, 0.5, 'y')
</pre>


<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>



<div class="figure">
<p><img src="obipy-resources/467229e018c81de612fc1dd2c5f44a1ac1ad632a/8988523c8198cb8f37c89adf0fdecb22db42b6fd.png" alt="8988523c8198cb8f37c89adf0fdecb22db42b6fd.png" />
</p>
</div>
</div>

<div id="outline-container-org0fa53c5" class="outline-3">
<h3 id="org0fa53c5"><span class="section-number-3">1.1</span> tanh</h3>
<div class="outline-text-3" id="text-1-1">
<p>
First we review the case of <code>tanh</code> which is a classic activation function. The <code>tanh</code> function is "active" between about &plusmn; 2.5, and outside that window it saturates. That means the derivative of this function becomes close to zero outside that window. So if you have large values of inputs, you should scale them to avoid this issue.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">xt</span> = np.linspace(-10, 10)
plt.plot(xt, np.tanh(xt))
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>)
</pre>
</div>

<pre class="example">
Text(0, 0.5, 'y')
</pre>


<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>



<div class="figure">
<p><img src="obipy-resources/467229e018c81de612fc1dd2c5f44a1ac1ad632a/cc7bac4b8de04e96360beeae49a9a3f5e519ccb9.png" alt="cc7bac4b8de04e96360beeae49a9a3f5e519ccb9.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">def</span> <span style="color: #006699;">objective1</span>(params, step=<span style="color: #D0372D;">None</span>):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">pred</span> = nn(params, np.array([X]).T)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">err</span> = np.array([Y]).T - pred
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.mean(err**2)

<span style="color: #0000FF;">from</span> autograd.misc.optimizers <span style="color: #0000FF;">import</span> adam
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> grad

<span style="color: #BA36A5;">params1</span> = init_random_params(0.1, layer_sizes=[1, 3, 1])

<span style="color: #BA36A5;">N</span> = 50
<span style="color: #BA36A5;">MAX_EPOCHS</span> = 500

<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(MAX_EPOCHS):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">params1</span> = adam(grad(objective1), params1,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> step_size=0.01, num_iters=N)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> i % 100 == 0:  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">print every 100th step</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'Step </span><span style="color: #BA36A5;">{i}</span><span style="color: #008000;">: </span><span style="color: #BA36A5;">{objective1(params1)}</span><span style="color: #008000;">'</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> objective1(params1, _) &lt; 2e-5:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Tolerance reached, stopping'</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">break</span>
</pre>
</div>

<p>
Step 0: 0.02031901154302905
Step 100: 8.146090083119546e-05
Tolerance reached, stopping
</p>

<p>
Now we can examine the fit and extrapolation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">X2</span> = np.linspace(-10, 10)
<span style="color: #BA36A5;">Y2</span> = X2**(1/3)
<span style="color: #BA36A5;">Z2</span> = nn(params1, X2.reshape([-1, 1]))

plt.plot(X2, Y2, <span style="color: #008000;">'b.'</span>, label=<span style="color: #008000;">'analytical'</span>)
plt.plot(X2, Z2, label=<span style="color: #008000;">'NN'</span>)
plt.fill_between(X2 &lt; 1, 0, 1.4, facecolor=<span style="color: #008000;">'gray'</span>, alpha=0.5)
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>);
</pre>
</div>

<p>
/Users/jkitchin/opt/anaconda3/lib/python3.7/site-packages/ipykernel_launcher.py:2: RuntimeWarning: invalid value encountered in power
</p>


<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>



<div class="figure">
<p><img src="obipy-resources/467229e018c81de612fc1dd2c5f44a1ac1ad632a/4187b1aa3040f7479026f08c9d92332674d1c7b4.png" alt="4187b1aa3040f7479026f08c9d92332674d1c7b4.png" />
</p>
</div>

<p>
For large enough \(x\), all of the <code>tanh</code> functions saturate at \(y=1\). So, the neural network also saturates at a constant value for large \(x\).
</p>

<p>
<b>exercise</b> Can you work out from the NN math what the saturated values should be?
</p>
</div>
</div>


<div id="outline-container-orgb3fd1b0" class="outline-3">
<h3 id="orgb3fd1b0"><span class="section-number-3">1.2</span> relu</h3>
<div class="outline-text-3" id="text-1-2">
<p>
A common activation function in deep learning is the Relu:
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">def</span> <span style="color: #006699;">relu</span>(x):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> x * (x &gt; 0)

plt.plot(X2, relu(X2))
</pre>
</div>

<pre class="example">
[&lt;matplotlib.lines.Line2D at 0x115545710&gt;]
</pre>


<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>



<div class="figure">
<p><img src="obipy-resources/467229e018c81de612fc1dd2c5f44a1ac1ad632a/14659610f47eec3051070131b0e0065bbf07338e.png" alt="14659610f47eec3051070131b0e0065bbf07338e.png" />
</p>
</div>

<p>
This is popular because if is very fast to compute, and the derivatives are constant. For positive \(x\) there is no saturation. For negative \(x\), however, the neuron is "dead".
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">def</span> <span style="color: #006699;">objective2</span>(par, step=<span style="color: #D0372D;">None</span>):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">pred</span> = nn(par, np.array([X]).T, activation=relu)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">err</span> = np.array([Y]).T - pred
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.mean(err**2)

<span style="color: #0000FF;">from</span> autograd.misc.optimizers <span style="color: #0000FF;">import</span> adam
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> grad

<span style="color: #BA36A5;">params2</span> = init_random_params(0.01, layer_sizes=[1, 3, 1])

<span style="color: #BA36A5;">N</span> = 50
<span style="color: #BA36A5;">MAX_EPOCHS</span> = 500

<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(MAX_EPOCHS):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">params2</span> = adam(grad(objective2), params2,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> step_size=0.01, num_iters=N)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> i % 100 == 0:  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">print every 100th step</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'Step </span><span style="color: #BA36A5;">{i}</span><span style="color: #008000;">: </span><span style="color: #BA36A5;">{objective2(params2)}</span><span style="color: #008000;">'</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> objective2(params2, _) &lt; 2e-5:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Tolerance reached, stopping'</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">break</span>
</pre>
</div>

<p>
Step 0: 0.021367865048848897
Step 100: 0.005829854754475911
Step 200: 0.0058296222524038075
Step 300: 0.005829395128164378
Step 400: 0.005829289683203641
</p>


<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">X2</span> = np.linspace(0., 1)
<span style="color: #BA36A5;">Y2</span> = X2**(1/3)
<span style="color: #BA36A5;">Z2</span> = nn(params2, X2.reshape([-1, 1]), activation=relu)

plt.plot(X2, Y2, <span style="color: #008000;">'b.'</span>, label=<span style="color: #008000;">'analytical'</span>)
plt.plot(X2, Z2, label=<span style="color: #008000;">'NN'</span>)
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>);
</pre>
</div>

<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>



<div class="figure">
<p><img src="obipy-resources/467229e018c81de612fc1dd2c5f44a1ac1ad632a/1c7789fb0bf6558fd0d5549537104203d7502529.png" alt="1c7789fb0bf6558fd0d5549537104203d7502529.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-ipython">params2
</pre>
</div>

<pre class="example">
[(array([[ 0.00154947,  1.19185304, -0.06849918]]),
  array([-0.01980796,  0.00939488, -0.05808362])),
 (array([[0.01230291],
         [0.5637435 ],
         [0.05575994]]),
  array([0.40197107]))]
</pre>

<p>
Notes:
</p>
<ol class="org-ol">
<li>The fit is not very good.</li>
<li>we have piecewise linear fits here.</li>
<li>There are negative weights, which means there are some "dead neurons". Maybe other initial guesses might improve this.</li>
</ol>

<p>
Let's look at the extrapolating behavior.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">X2</span> = np.linspace(0, 1)
<span style="color: #BA36A5;">Y2</span> = X2**(1/3)

<span style="color: #BA36A5;">xf</span> = np.linspace(-2, 2)
<span style="color: #BA36A5;">Z2</span> = nn(params2, xf.reshape([-1, 1]), activation=relu)

plt.plot(X2, Y2, <span style="color: #008000;">'b.'</span>, label=<span style="color: #008000;">'analytical'</span>)
plt.plot(xf, Z2, label=<span style="color: #008000;">'NN'</span>)
plt.fill_between(X2 &lt; 1, 0, 1.4, facecolor=<span style="color: #008000;">'gray'</span>, alpha=0.5)
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>);
</pre>
</div>

<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>



<div class="figure">
<p><img src="obipy-resources/467229e018c81de612fc1dd2c5f44a1ac1ad632a/dca1cf66167174a61a8ba58e5b2baf9ad7e00e60.png" alt="dca1cf66167174a61a8ba58e5b2baf9ad7e00e60.png" />
</p>
</div>

<p>
Notes this extrapolates linearly on the right, and is constant on the left. These are properties of the Relu.
</p>
</div>
</div>

<div id="outline-container-orgea866a1" class="outline-3">
<h3 id="orgea866a1"><span class="section-number-3">1.3</span> Gaussian (radial basis function)</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Finally we consider the Gaussian activation function.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">def</span> <span style="color: #006699;">rbf</span>(x):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.exp(-x**2)

<span style="color: #BA36A5;">x3</span> = np.linspace(-3, 3)
plt.plot(x3, rbf(x3))
</pre>
</div>

<pre class="example">
[&lt;matplotlib.lines.Line2D at 0x1159a7490&gt;]
</pre>


<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>



<div class="figure">
<p><img src="obipy-resources/467229e018c81de612fc1dd2c5f44a1ac1ad632a/05adb5b9767601cf93b454448c05c41a0ba2e052.png" alt="05adb5b9767601cf93b454448c05c41a0ba2e052.png" />
</p>
</div>

<p>
Now we fit the data.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">def</span> <span style="color: #006699;">objective3</span>(pars, step=<span style="color: #D0372D;">None</span>):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">pred</span> = nn(pars, np.array([X]).T, activation=rbf)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">err</span> = np.array([Y]).T - pred
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.mean(err**2)

<span style="color: #0000FF;">from</span> autograd.misc.optimizers <span style="color: #0000FF;">import</span> adam
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> grad

<span style="color: #BA36A5;">params3</span> = init_random_params(0.1, layer_sizes=[1, 3, 1])

<span style="color: #BA36A5;">N</span> = 50
<span style="color: #BA36A5;">MAX_EPOCHS</span> = 500

<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(MAX_EPOCHS):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">params3</span> = adam(grad(objective3), params3,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> step_size=0.01, num_iters=N)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> i % 100 == 0:  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">print every 100th step</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'Step </span><span style="color: #BA36A5;">{i}</span><span style="color: #008000;">: </span><span style="color: #BA36A5;">{objective3(params3)}</span><span style="color: #008000;">'</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> objective3(params3, _) &lt; 2e-5:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Tolerance reached, stopping'</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">break</span>
</pre>
</div>

<p>
Step 0: 0.04493958596201498
Step 100: 0.0011542874884390897
Step 200: 0.001087692050875522
Step 300: 0.0010358096429038638
Step 400: 0.0009656108916493105
</p>



<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">X2</span> = np.linspace(0., 1)
<span style="color: #BA36A5;">Y2</span> = X2**(1/3)
<span style="color: #BA36A5;">Z2</span> = nn(params3, X2.reshape([-1, 1]), activation=rbf)

plt.plot(X2, Y2, <span style="color: #008000;">'b.'</span>, label=<span style="color: #008000;">'analytical'</span>)
plt.plot(X2, Z2, label=<span style="color: #008000;">'NN'</span>)
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>);
</pre>
</div>

<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>



<div class="figure">
<p><img src="obipy-resources/467229e018c81de612fc1dd2c5f44a1ac1ad632a/1c7735e7814c919fe3fb2740f7f01f2b86b2d409.png" alt="1c7735e7814c919fe3fb2740f7f01f2b86b2d409.png" />
</p>
</div>



<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">X2</span> = np.linspace(-2.5, 4)
<span style="color: #BA36A5;">Y2</span> = X2**(1/3)
<span style="color: #BA36A5;">Z2</span> = nn(params3, X2.reshape([-1, 1]), activation=rbf)

plt.plot(X2, Y2, <span style="color: #008000;">'b.'</span>, label=<span style="color: #008000;">'analytical'</span>)
plt.plot(X2, Z2, label=<span style="color: #008000;">'NN'</span>)
plt.fill_between(X2 &lt; 1, 0, 1.4, facecolor=<span style="color: #008000;">'gray'</span>, alpha=0.5)
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>);
</pre>
</div>

<p>
/Users/jkitchin/opt/anaconda3/lib/python3.7/site-packages/ipykernel_launcher.py:2: RuntimeWarning: invalid value encountered in power
</p>


<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>



<div class="figure">
<p><img src="obipy-resources/467229e018c81de612fc1dd2c5f44a1ac1ad632a/64b38c5f00086b449069a823a8b86c01fcfc9691.png" alt="64b38c5f00086b449069a823a8b86c01fcfc9691.png" />
</p>
</div>

<p>
Notes this extrapolates to zero when you are far from the data. It fits reasonably in the region trained. "If your function is nonlinear enough, somewhere the nonlinearity matches your data." (Z. Ulissi).
</p>
</div>
</div>

<div id="outline-container-org062a653" class="outline-3">
<h3 id="org062a653"><span class="section-number-3">1.4</span> Summary</h3>
<div class="outline-text-3" id="text-1-4">
<p>
We can think of single layer neural networks as partial expansions in the activation function space. That means the extrapolation behavior will be like the dominating feature of the activation functions, e.g. relu extrapolates like a line, tanh saturates at large x, and Gaussians effectively go to zero. Unexpected things can happen at the edges of the data, so at intermediate extrapolations you do not always know what will happen.
</p>
</div>
</div>
</div>


<div id="outline-container-org8e4d192" class="outline-2">
<h2 id="org8e4d192"><span class="section-number-2">2</span> Train/test splits on data</h2>
<div class="outline-text-2" id="text-2">
<p>
So far we have not considered how to split your data when fitting. This becomes important for a few reasons:
</p>

<ol class="org-ol">
<li>We need to be able to tell if we are overfitting. One way to do this is to compare fitting errors to prediction errors.</li>
</ol>

<p>
This means we need a way to split a dataset into a train set and a test set. Then, we can do training on the train set, and testing on the test set.
</p>

<p>
Let's start by remembering what our dataset is.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">X</span> = np.linspace(0, 1)
<span style="color: #BA36A5;">Y2</span> = X**(1/3)
</pre>
</div>

<p>
The way to split this is that we use indexing. We start by making an array of integers.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">ind</span> = np.arange(<span style="color: #006FE0;">len</span>(X))
ind
</pre>
</div>

<pre class="example">
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
       17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
       34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49])
</pre>


<p>
Next, we randomly shuffle the array of integers.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">pind</span> = np.random.permutation(ind)
pind
</pre>
</div>

<pre class="example">
array([ 9,  5, 25, 20, 36, 14, 42, 13,  2,  7, 10, 29, 16,  4, 31, 47, 19,
       27, 34, 21, 44,  6, 26, 37, 35,  8, 24, 23, 45, 40,  1, 48, 17, 30,
       43, 15, 22, 18, 33,  0, 46, 49, 32,  3, 28, 11, 39, 12, 41, 38])
</pre>

<p>
Next, we decide on the train/test split. A common choice is 80/20. We find the integer that is closest to 80% of the index array.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">split</span> = <span style="color: #006FE0;">int</span>(0.8 * <span style="color: #006FE0;">len</span>(pind))
split
</pre>
</div>

<pre class="example">
40
</pre>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">train_ind</span> = pind[:split]
<span style="color: #BA36A5;">test_ind</span> = pind[split:]
(<span style="color: #006FE0;">len</span>(train_ind), <span style="color: #006FE0;">len</span>(test_ind))
</pre>
</div>

<pre class="example">
(40, 10)
</pre>

<p>
We check that we have a reasonable choice here.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">train_x</span> = X[train_ind]
<span style="color: #BA36A5;">train_y</span> = Y2[train_ind]

<span style="color: #BA36A5;">test_x</span> = X[test_ind]
<span style="color: #BA36A5;">test_y</span> = Y2[test_ind]
plt.plot(test_x, test_y, <span style="color: #008000;">'ro'</span>)
plt.plot(train_x, train_y, <span style="color: #008000;">'bo'</span>)
</pre>
</div>

<pre class="example">
[&lt;matplotlib.lines.Line2D at 0x115edc950&gt;]
</pre>


<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>



<div class="figure">
<p><img src="obipy-resources/467229e018c81de612fc1dd2c5f44a1ac1ad632a/0a3fa0745ef90658d4aac9d57be78a5db6aa66db.png" alt="0a3fa0745ef90658d4aac9d57be78a5db6aa66db.png" />
</p>
</div>

<p>
Now, we train on the train data.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">def</span> <span style="color: #006699;">objective10</span>(params, step=<span style="color: #D0372D;">None</span>):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">pred</span> = nn(params, np.array([train_x]).T)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">err</span> = np.array([train_y]).T - pred
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.mean(err**2)

<span style="color: #0000FF;">from</span> autograd.misc.optimizers <span style="color: #0000FF;">import</span> adam
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> grad

<span style="color: #BA36A5;">params10</span> = init_random_params(0.1, layer_sizes=[1, 3, 1])

<span style="color: #BA36A5;">N</span> = 50
<span style="color: #BA36A5;">MAX_EPOCHS</span> = 500

<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(MAX_EPOCHS):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">params10</span> = adam(grad(objective10), params10,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> step_size=0.01, num_iters=N)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> i % 100 == 0:  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">print every 100th step</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'Step </span><span style="color: #BA36A5;">{i}</span><span style="color: #008000;">: </span><span style="color: #BA36A5;">{objective10(params10)}</span><span style="color: #008000;">'</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> objective10(params10, _) &lt; 2e-5:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Tolerance reached, stopping'</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">break</span>
</pre>
</div>

<p>
Step 0: 0.01901760206790496
Step 100: 4.142492030081142e-05
Tolerance reached, stopping
</p>

<p>
As usual, we should check the fit on the train data. This is a little trickier than before, because the points are out of order.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">Z2</span> = nn(params1, train_x.reshape([-1, 1]))
plt.plot(train_x, Z2, <span style="color: #008000;">'bo'</span>, label=<span style="color: #008000;">'NN'</span>)
plt.plot(train_x, train_y, <span style="color: #008000;">'r.'</span>, label=<span style="color: #008000;">'analytical'</span>)
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>)

plt.plot(test_x, nn(params1, test_x.reshape([-1, 1])), <span style="color: #008000;">'go'</span>, label=<span style="color: #008000;">'NN'</span>)
plt.plot(test_x, test_y, <span style="color: #008000;">'y.'</span>, label=<span style="color: #008000;">'analytical'</span>)
</pre>
</div>

<pre class="example">
[&lt;matplotlib.lines.Line2D at 0x11607c990&gt;]
</pre>


<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>



<div class="figure">
<p><img src="obipy-resources/467229e018c81de612fc1dd2c5f44a1ac1ad632a/088fc3b3af4e30087e26f454339d404b566450fe.png" alt="088fc3b3af4e30087e26f454339d404b566450fe.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">rmse_train</span> = np.mean((train_y - nn(params1, train_x.reshape([-1, 1]))**2))
<span style="color: #BA36A5;">rmse_test</span> =  np.mean((test_y - nn(params1, test_x.reshape([-1, 1]))**2))

<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'''RMSE train = {rmse_train:1.3f}</span>
<span style="color: #008000;">RMSE test = {rmse_test:1.3f}'''</span>)
</pre>
</div>

<p>
RMSE train = 0.154
RMSE test = 0.120
</p>


<p>
For the train/test split to be meaningful, it is important that the two datasets have similar distributions of values.
</p>
</div>
</div>

<div id="outline-container-orgaff0d8a" class="outline-2">
<h2 id="orgaff0d8a"><span class="section-number-2">3</span> Summary</h2>
<div class="outline-text-2" id="text-3">
<p>
Today we reviewed the role of activation functions in neural networks, and observed that it doesn't generally matter what you use (but the details always matter in individual cases). The mathematical form of these activation functions determines how they will extrapolate, which can be important depending on your application.
</p>

<p>
We then explored how to efficiently split a dataset into a train and test set so that overfitting can be evaluated. This becomes increasingly important for when you plan to explore many models (choices of hyperparameters), and then you split the data three ways (train, test and validate).
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: John Kitchin</p>
<p class="date">Created: 2020-03-31 Tue 07:32</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
